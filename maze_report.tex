\documentclass[11pt]{article}
\usepackage[margin=1.5cm]{geometry}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{tcolorbox}
\usepackage{hyperref}
\tcbuselibrary{listings, skins}

\definecolor{maincs}{RGB}{0,255,0}
\definecolor{secondarycs}{RGB}{255,179,246}

\newcommand\tab[1][.5in]{\hspace*{#1}}

\lstset{
    language=Python,
        numbers=left,
        numberstyle=\small,
        numbersep=8pt,
        frame=single,
        framexleftmargin=15pt,
        basicstyle=\fontsize{9}{10}\ttfamily,
        otherkeywords={self,import,from},
        keywordstyle=\color{purple}\ttfamily,
        emph={True,False},
        emphstyle=\color{orange},
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{blue}\ttfamily,
        morecomment=[l][\color{blue}]{\#},
        tabsize=2,
        showstringspaces=false
}

\begin{document}
\begin{titlepage}
\vspace*{\fill}
{
    \centering
    \bfseries
    \emph{\Huge Grandfather's Maze Algorithm Report}
    \vskip 1.5in

    \Large Robbie Merillat \\
    \vskip 2in

    26 April 2017

}
\vspace*{\fill}
\clearpage
\end{titlepage}

\section{Modeling the Problem}
\tab In 
\newpage
\section{The Code}
\begin{lstlisting}[caption= Maze Model]
# Container Object, each edge is stored in a hash map as as 
# (start,end):(color, type, [Adjacency List])
Maze = {}

# Read in first line from file,
# that first line is not used in this program so nothing is done with it
text_file = open("input.txt", "r")
text_file.readline()

# For each subsequent line, 
# create one forward traveling and one backwards traveling "node" 
# representing each edge in the Maze
for line in text_file:
    start, end, color, typ = line.split()
    Maze[(start,end)] = (color, typ, [])
    Maze[(end,start)] = (color, typ, [])

# Check start and end nodes and link together adjacent nodes
for key, value in Maze.items():
    for k, v in Maze.items():
       if ((key[1] == k[0]) and (key[0] != k[1]) and (value[0] == v[0] or value[1] == v[1])):
           value[2].append(k)

\end{lstlisting}
\begin{lstlisting}[caption=BFS]
#Bredth First Search
S = set()
Q = deque([]) # to be used as a queue

root = ('A','B')
goal = ('i','j')

#add root to set and queue
S.add(root)
Q.append(root)

#Backtrace dictionary stored as (child):(parent)
Backtrace = {}
Backtrace[root] = None

while Q:
    current = Q.popleft()
    if current == goal:
        break
    val = Maze[current]
    for n in val[2]:
        if n not in S:
            S.add(n)
            Backtrace[n] = current
            Q.append(n)
\end{lstlisting}

\begin{lstlisting}[caption=Traceback]

#Backtrace to build path
path = []
path.append(goal)
node = goal
while current != root:
    current = Backtrace[node]
    path.append(current)
    node = current

\end{lstlisting}

\newpage

\section{Program Output}
The code that I generated results in the following output into the console ... \\\\
The path through the maze takes 49 steps and follows the path : 
[('A', 'B'), ('B', 'E'), ('E', 'O'), ('O', 'U'), ('U', 'V'), ('V', 'a'), ('a', 'f'), ('f', 'Z'), ('Z', 'U'), ('U', 'O'), ('O', 'E'), ('E', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'J'), ('J', 'N'), ('N', 'T'), ('T', 'S'), ('S', 'R'), ('R', 'Q'), ('Q', 'P'), ('P', 'K'), ('K', 'F'), ('F', 'G'), ('G', 'L'), ('L', 'Q'), ('Q', 'W'), ('W', 'b'), ('b', 'a'), ('a', 'Z'), ('Z', 'V'), ('V', 'W'), ('W', 'X'), ('X', 'S'), ('S', 'Y'), ('Y', 'e'), ('e', 'd'), ('d', 'S'), ('S', 'M'), ('M', 'I'), ('I', 'D'), ('D', 'G'), ('G', 'K'), ('K', 'O'), ('O', 'V'), ('V', 'b'), ('b', 'h'), ('h', 'i'), ('i', 'j')] \\
\end{document}
